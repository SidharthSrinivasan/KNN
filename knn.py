# -*- coding: utf-8 -*-
"""K Nearest Neighbours

Automatically generated by Colaboratory.

Original file is located at
    https://colab.research.google.com/drive/1DeOFjsKkBBnZhlhhIc8mCStH68k0DGgc

Import modules
"""

import torch
from torchvision import datasets, transforms
import numpy as np
import timeit
from collections import OrderedDict
from pprint import pformat

"""

```
# This is formatted as code
```

Function to run k-NN algorithm and compute its accuracy and runtime"""

def run(x_train, y_train, x_test, y_test, n_classes, device, n_runs):
    if device != 'cpu' and torch.cuda.is_available():
        device = torch.device("cuda")
        print('Running on GPU: {}'.format(torch.cuda.get_device_name(0)))
    else:
        device = torch.device("cpu")
        print('Running on CPU')

    run_times = []

    for i in range(n_runs):
        start = timeit.default_timer()
        # np.random.seed(0)
        predicted_y_test = knn(x_train, y_train, x_test, n_classes, device)
        # np.random.seed()
        stop = timeit.default_timer()
        run_time = stop - start
        run_times.append(run_time)

        print(f'run {i + 1} : run_time: {run_time}')

    assert isinstance(predicted_y_test, np.ndarray), "predicted test labels must be returned as a numpy array"

    correct_predict = (y_test
                       == predicted_y_test).astype(np.int32).sum()
    accuracy = float(correct_predict) / len(y_test)

    run_time = min(run_times)

    print('Correct Predictions: {}/{} total \tAccuracy: {:5f} \tTime: {:2f}'.format(correct_predict,
                                                                                    len(y_test), accuracy, run_time))
    return correct_predict, accuracy, run_time

"""TODO: Implement knn here"""

import torch
import numpy as np


def knn(x_train, y_train, x_test, n_classes, device):
    """
    x_train: 60000 x 784 matrix: each row is a flattened image of an MNIST digit
    y_train: 60000 vector: label for x_train
    x_test: 1000 x 784 testing images
    n_classes: no. of classes in the classification task
    device: pytorch device on which to run the code
    return: predicted y_test which is a 1000-sized vector
    """
    """
    x_train: 60000 x 784 matrix: each row is a flattened image of an MNIST digit
    y_train: 60000 vector: label for x_train
    x_test: 5000 x 784 testing images
    return: predicted y_test which is a 5000 vector
    """

    k_value = 5
    train_set_tensor = torch.as_tensor(x_train, dtype=float, device=device)
    test_set_tensor = torch.as_tensor(x_test, dtype=float, device=device)
    y_test = []

    for test_image in range(1000):
        test_tensor = test_set_tensor[test_image]

        distance = test_tensor - train_set_tensor
        distance = torch.norm(distance, dim=1)

        _, k_indices = torch.topk(distance, k_value, largest=False)

        selected_classes = y_train[k_indices.cpu().numpy()]
        values, counts = np.unique(selected_classes, return_counts=True)
        max_class = values[np.argmax(counts)]

        y_test.append(max_class)

    return np.array(y_test)

"""Main function"""

def main():
    min_acc_thres = 0.84
    max_acc_thres = 0.94

    min_runtime_thres = 12
    max_runtime_thres = 24

    n_runs = 5

    n_classes = 10
    # change to cpu to run on CPU
    device = 'gpu'

    mnist_train = datasets.MNIST('data', train=True, download=True,
                                 transform=transforms.Compose([
                                     transforms.Normalize((0.1307,), (0.3081,)),
                                 ])
                                 )
    mnist_test = datasets.MNIST('data', train=False, download=True,
                                transform=transforms.Compose([
                                    transforms.Normalize((0.1307,), (0.3081,)),
                                ])
                                )
    # convert pytorch tensors to numpy arrays
    (x_train, y_train) = (mnist_train.data.cpu().numpy(), mnist_train.targets.cpu().numpy())
    (x_valid, y_valid) = (mnist_test.data.cpu().numpy(), mnist_test.targets.cpu().numpy())

    # flatten 28x28 images into 784 sized vectors
    x_train = x_train.reshape(x_train.shape[0], -1)
    x_valid = x_valid.reshape(x_valid.shape[0], -1)

  
    (x_valid, y_valid) = (x_valid[:1000], y_valid[:1000])

    print("Dimension of dataset: ")
    print("Train:", x_train.shape, y_train.shape, "\nTest:", x_valid.shape, y_valid.shape)

    (correct_predict, accuracy, run_time) = run(x_train, y_train, x_valid, y_valid, n_classes, device, n_runs)

    result = OrderedDict(correct_predict=correct_predict,
                         accuracy=accuracy,
                         run_time=run_time,
                         )

    with open('result.txt', 'w') as f:
        f.writelines(pformat(result, indent=4))

    print(pformat(result, indent=4))

"""Call the main function. You can only run this after filling the _knn_ function above"""

main()